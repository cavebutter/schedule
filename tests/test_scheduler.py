
from src.scheduler import *
from collections import Counter
import pytest

class TestGroups:

    #  Tests that the function can create 2 equal sized groups from a list of even length
    def test_even_length_list(self):
        # Arrange
        teams = ['Team1', 'Team2', 'Team3', 'Team4']
    
        # Act
        result = groups(teams)
    
        # Assert
        assert len(result['group1']) == len(result['group2'])
        assert len(result['group1']) == 2
        assert len(result['group2']) == 2

    #  Tests that the function can create 2 equal sized groups from a list of odd length
    def test_odd_length_list(self):
        # Arrange
        teams = ['Team1', 'Team2', 'Team3']
    
        # Act
        result = groups(teams)
    
        # Assert
        assert len(result['group1']) == len(result['group2'])
        assert len(result['group1']) == 2
        assert len(result['group2']) == 2

    #  Tests that the function can handle an empty list input
    def test_empty_list(self):
        # Arrange
        teams = []
    
        # Act
        result = groups(teams)
    
        # Assert
        assert len(result['group1']) == len(result['group2'])
        assert len(result['group1']) == 0
        assert len(result['group2']) == 0




class TestEligibleGameDays:

    #  Tests that the function returns the correct list of game days when the tournament start and end dates are exactly one week apart and the game_days list contains all days of the week.
    def test_tournament_one_week_all_days(self):
        # Arrange
        tournament_start = "2022-01-01"
        tournament_end = "2022-01-07"
        game_days = [0, 1, 2, 3, 4, 5, 6]

        # Act
        result = eligible_game_days(tournament_start, tournament_end, game_days)

        # Assert
        assert result == ["Sat Jan 01, 2022", "Sun Jan 02, 2022", "Mon Jan 03, 2022", "Tue Jan 04, 2022",
                          "Wed Jan 05, 2022", "Thu Jan 06, 2022", "Fri Jan 07, 2022"]

    def test_tournament_one_week_one_day(self):
        # Arrange
        tournament_start = "2022-01-01"
        tournament_end = "2022-01-07"
        game_days = [0]

        # Act
        result = eligible_game_days(tournament_start, tournament_end, game_days)

        # Assert
        assert result == ["Mon Jan 03, 2022"]

    def test_tournament_one_week_multiple_days(self):
        # Arrange
        tournament_start = "2023-01-01"
        tournament_end = "2023-01-07"
        game_days = [1, 3, 5]

        # Act
        result = eligible_game_days(tournament_start, tournament_end, game_days)

        # Assert
        assert result == ['Tue Jan 03, 2023', 'Thu Jan 05, 2023', 'Sat Jan 07, 2023']

    #  Tests that the function returns the correct list of game days when the tournament start and end dates are more than one week apart and the game_days list contains all days of the week.
    def test_tournament_more_than_one_week_all_days(self):
        # Arrange
        tournament_start = "2022-01-01"
        tournament_end = "2022-01-14"
        game_days = [0, 1, 2, 3, 4, 5, 6]

        # Act
        result = eligible_game_days(tournament_start, tournament_end, game_days)

        # Assert
        assert result == ["Sat Jan 01, 2022", "Sun Jan 02, 2022", "Mon Jan 03, 2022", "Tue Jan 04, 2022",
                          "Wed Jan 05, 2022", "Thu Jan 06, 2022", "Fri Jan 07, 2022", "Sat Jan 08, 2022",
                          "Sun Jan 09, 2022", "Mon Jan 10, 2022", "Tue Jan 11, 2022", "Wed Jan 12, 2022",
                          "Thu Jan 13, 2022", "Fri Jan 14, 2022"]

    #  Tests that the function returns the correct list of game days when the tournament start and end dates are more than one week apart and the game_days list contains only one day of the week.
    def test_tournament_more_than_one_week_one_day(self):
        # Arrange
        tournament_start = "2023-01-01"
        tournament_end = "2023-01-14"
        game_days = [0]

        # Act
        result = eligible_game_days(tournament_start, tournament_end, game_days)

        # Assert
        assert result == ['Mon Jan 02, 2023', 'Mon Jan 09, 2023']


# Generated by CodiumAI

import pytest


class TestCreateGames:

    #  Tests that the function returns a list of Game objects when valid parameters are passed.
    def test_valid_parameters_returns_list_of_game_objects(self):
        # Arrange
        start_date = "2022-01-01"
        end_date = "2022-01-07"
        gamedays = [0, 1, 2, 3, 4, 5, 6]
        fields = ["Field A", "Field B"]
        time_slots = ["Morning", "Afternoon", "Evening"]

        # Act
        result = create_games(start_date, end_date, gamedays, fields, time_slots)

        # Assert
        assert isinstance(result, list)
        assert all(isinstance(game, Game) for game in result)

    #  Tests that the function returns a list of eligible game days.
    def test_eligible_game_days_returns_empty_list(self):
        # Arrange
        start_date = "2022-01-08"
        end_date = "2022-01-11"
        gamedays = [3]
        fields = ["Field A", "Field B"]
        time_slots = ["Morning", "Afternoon", "Evening"]

        # Act
        result = create_games(start_date, end_date, gamedays, fields, time_slots)

        # Assert
        assert isinstance(result, list)
        assert len(result) == 0

    #  Tests that the function returns a list of Game objects when only one eligible game day is found.
    def test_one_eligible_game_day_returns_list_of_game_objects(self):
        # Arrange
        start_date = "2022-01-01"
        end_date = "2022-01-01"
        gamedays = [0, 1, 2, 3, 4, 5, 6]
        fields = ["Field A", "Field B"]
        time_slots = ["Morning", "Afternoon", "Evening"]

        # Act
        result = create_games(start_date, end_date, gamedays, fields, time_slots)

        # Assert
        assert isinstance(result, list)
        assert all(isinstance(game, Game) for game in result)



# Generated by CodiumAI

import pytest

class TestAssignWeek:

    #  Tests that the week number is assigned correctly when the start date is before the game day
    def test_assign_week_start_before_game_day(self):
        # Arrange
        start_date = "2022-01-01"
        game = Game("Field A", "10:00", "2022-01-10")

        # Act
        game.assign_week(start_date)

        # Assert
        assert game.week_no == 1

    #  Tests that the week number is assigned correctly when the start date is the same as the game day
    def test_assign_week_start_same_as_game_day(self):
        # Arrange
        start_date = "2022-01-10"
        game = Game("Field A", "10:00", "2022-01-10")

        # Act
        game.assign_week(start_date)

        # Assert
        assert game.week_no == 0

    #  Tests that the week number is assigned correctly when the start date is after the game day
    def test_assign_week_start_after_game_day(self):
        # Arrange
        start_date = "2022-01-20"
        game = Game("Field A", "10:00", "2022-01-10")

        # Act
        game.assign_week(start_date)

        # Assert
        assert game.week_no == -1

    #  Tests that the week number is assigned correctly when the start date is in a leap year
    def test_assign_week_leap_year(self):
        # Arrange
        start_date = "2020-01-01"
        game = Game("Field A", "10:00", "2020-01-10")

        # Act
        game.assign_week(start_date)

        # Assert
        assert game.week_no == 1

    #  Tests that the week number is assigned correctly when the start date is in a non-leap year
    def test_assign_week_non_leap_year(self):
        # Arrange
        start_date = "2021-01-01"
        game = Game("Field A", "10:00", "2021-01-10")

        # Act
        game.assign_week(start_date)

        # Assert
        assert game.week_no == 1

def test_load_data():
    # Arrange
    data_file = "data/time_slots.csv"

    # Act
    data_list = load_data(data_file)

    # Assert
    assert isinstance(data_list, list)


class TestTrimSched:

    #  Tests that the function correctly removes games with invalid timeslots for their day of the week
    def test_all_day_games(self):
        # Arrange
        night_games_only = [0, 1, 2, 3, 4]
        day_games_only = [5, 6]
        games = [
            Game(gameday='2021-01-02', time_slot='Day', field='Field A'), # Saturday - Should remain
            Game(gameday='2021-01-03', time_slot='Night', field='Field A'), # Sunday - Should remove night game on Sunaay
            Game(gameday='2021-01-04', time_slot='Night', field='Field A'),  # Monday - Should remain
            Game(gameday='2021-01-05', time_slot='Night', field='Field A'),  # Tuesday - Should remain
            Game(gameday='2021-01-06', time_slot='Day', field='Field A'),  # Wednesday - Should remove day game on Wed
        ]

        # Act
        results = trim_sched(games, day_games_only, night_games_only)
        res_gamedays = [result.gameday for result in results]

        # Assert
        expected_result = ['2021-01-02','2021-01-04','2021-01-05']
        assert res_gamedays == expected_result

class TestTeam:

    #  Tests that a Team object can be created with valid inputs
    def test_create_team_with_valid_inputs(self):
        # Arrange
        team_name = "Team A"
        level = "Beginner"

        # Act
        team = Team(team_name, level)

        # Assert
        assert team.team_name == team_name
        assert team.level == level
        assert team.home_game_count == 0
        assert team.away_game_count == 0

    #  Tests that the home_game_count is incremented by 1
    def test_increment_home_count(self):
        # Arrange
        team_name = "Team A"
        level = "Beginner"
        team = Team(team_name, level)

        # Act
        team.increment_home_count()

        # Assert
        assert team.home_game_count == 1

    #  Tests that the away_game_count is incremented by 1
    def test_increment_away_count(self):
        # Arrange
        team_name = "Team A"
        level = "Beginner"
        team = Team(team_name, level)

        # Act
        team.increment_away_count()

        # Assert
        assert team.away_game_count == 1

    #  Tests that a Team object cannot be created with an empty team_name
    def test_create_team_with_empty_team_name(self):
        # Arrange
        team_name = ""
        level = "Beginner"

        # Act and Assert
        with pytest.raises(ValueError):
            Team(team_name, level)

    #  Tests that a Team object cannot be created with an empty level
    def test_create_team_with_empty_level(self):
        # Arrange
        team_name = "Team A"
        level = ""

        # Act and Assert
        with pytest.raises(ValueError):
            Team(team_name, level)


class TestAssignTeamsToGame:

    #  Tests that the method assigns the first team in the match tuple to the home team and the second team to the away team, and increments the home_game_count and away_game_count for the respective teams.
    def test_assign_teams_to_game_happy_path(self):
        # Arrange
        team1 = Team("Team 1", "Level 1")
        team2 = Team("Team 2", "Level 2")
        game = Game("Field 1", "10:00 AM", "2022-01-01")

        # Act
        game.assign_teams_to_game((team1, team2))

        # Assert
        assert game.hometeam == team1
        assert game.awayteam == team2
        assert team1.home_game_count == 1
        assert team2.away_game_count == 1

    #  Tests that the method can handle assigning multiple games to the same team, and increments the home_game_count and away_game_count for the team accordingly.
    def test_assign_teams_to_game_multiple_games(self):
        # Arrange
        team = Team("Team 1", "Level 1")
        game1 = Game("Field 1", "10:00 AM", "2022-01-01")
        game2 = Game("Field 2", "2:00 PM", "2022-01-02")

        # Act
        game1.assign_teams_to_game((team, Team("Team 2", "Level 2")))
        game2.assign_teams_to_game((team, Team("Team 3", "Level 3")))

        # Assert
        assert game1.hometeam == team
        assert game2.hometeam == team
        assert team.home_game_count == 2

    #  Tests that the method can handle assigning multiple games to different teams, and increments the home_game_count and away_game_count for the respective teams.
    def test_assign_teams_to_game_different_teams(self):
        # Arrange
        team1 = Team("Team 1", "Level 1")
        team2 = Team("Team 2", "Level 2")
        game1 = Game("Field 1", "10:00 AM", "2022-01-01")
        game2 = Game("Field 2", "2:00 PM", "2022-01-02")

        # Act
        game1.assign_teams_to_game((team1, team2))
        game2.assign_teams_to_game((team2, team1))

        # Assert
        assert game1.hometeam == team1
        assert game1.awayteam == team2
        assert game2.hometeam == team2
        assert game2.awayteam == team1
        assert team1.home_game_count == 1
        assert team1.away_game_count == 1
        assert team2.home_game_count == 1
        assert team2.away_game_count == 1

    #  Tests the edge cases where the first element of 'match' is not an instance of the 'Team' class and raises a ValueError, and where the second element of 'match' is not an instance of the 'Team' class and raises a ValueError.
    # def test_assign_teams_to_game_edge_cases(self):
    #     # Arrange
    #     team = Team("Team 1", "Level 1")
    #     game = Game("Field 1", "10:00 AM", "2022-01-01")
    #
    #     # Assert ValueError is raised when first element of 'match' is not an instance of the 'Team' class
    #     with pytest.raises(ValueError):
    #         game.assign_teams_to_game(("Not a Team", team))
    #
    #     # Assert ValueError is raised when second element of 'match' is not an instance of the 'Team' class
    #     with pytest.raises(ValueError):
    #         game.assign_teams_to_game((team, "Not a Team"))


class TestLoadTeams:

    #  Tests that the function can load a csv file containing multiple teams with different levels
    def test_csv_file_with_multiple_teams_with_different_levels(self, mocker):
        # Arrange
        data_file = 'multiple_teams_different_levels.csv'
        mocker.patch('os.path.isfile', return_value=True)
        mocker.patch('builtins.open', mocker.mock_open(read_data='team1,level1\nteam2,level2\nteam3,level3\n'))

        # Act
        result = load_teams(data_file)

        # Assert
        assert len(result['level1']) == 1
        assert len(result['level2']) == 1
        assert len(result['level3']) == 1

    #  Tests that the function can load a csv file containing multiple teams with the same level
    def test_csv_file_with_multiple_teams_with_same_level(self, mocker):
        # Arrange
        data_file = 'multiple_teams_same_level.csv'
        mocker.patch('os.path.isfile', return_value=True)
        mocker.patch('builtins.open', mocker.mock_open(read_data='team1,level1\nteam2,level1\nteam3,level1\n'))

        # Act
        result = load_teams(data_file)

        # Assert
        assert len(result['level1']) == 3

class TestLoadMatchups:

    #  Tests that the function can successfully load a valid CSV file and return a dictionary with the correct key-value pairs.
    #  Note:  I am dumb.  You will have to replace the path to datafile with the absolute path on your implementation
    def test_valid_csv_file(self, mocker):
        # Arrange
        data_file = 'C:\\Users\\JayCohen\\OneDrive - The Canton Group\\dev\\schedule\\data\\matchups.csv'
        expected_result = {'tball': 1, 'farm': 2, 'aa': 3}

        # Act
        result = load_matchups(data_file)

        # Assert
        assert result == expected_result

class TestGroupsThree:

    # Test that the number of matches produced = (n * m * (n-1)) / 2.
    def test_groups_three_count(self):
        # Arrange
        teams_file = 'C:\\Users\\JayCohen\\OneDrive - The Canton Group\\dev\\schedule\\data\\small_even_teams.csv'
        matchups_file = 'C:\\Users\\JayCohen\\OneDrive - The Canton Group\\dev\\schedule\\data\\matchups.csv'
        expected_result = 12

        # Act
        teams = load_teams(teams_file)
        matches = load_matchups(matchups_file)
        result = groups_three(teams, matches)

        # Assert
        assert len(result) == expected_result


    # Test that the matches created are the correct matches for two levels
    def test_groups_three(self):
        # Arrange
        teams = {
            'level1': ['team1', 'team2', 'team3', 'team4'],
            'level2': ['team5', 'team6']
        }
        matchups = {
            'level1': 1,
            'level2': 2
        }
        expected_result = [('team1', 'team2'), ('team1', 'team3'), ('team1', 'team4'), ('team2', 'team3'),
                            ('team2', 'team4'), ('team3', 'team4'), ('team5', 'team6'), ('team6', 'team5')]


        # Act
        result = groups_three(teams, matchups)

        # Convert tuples to strings
        expected_result = [str(matchup) for matchup in expected_result]
        result = [str(matchup) for matchup in result]

        # Assert
        assert Counter(result) == Counter(expected_result)
